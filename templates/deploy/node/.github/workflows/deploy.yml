name: Build and Deploy Node.js App

on:
  push:
    branches:
      - ${PROD_BRANCH:-main}
      - ${DEV_BRANCH:-development}
  pull_request:
    branches:
      - ${PROD_BRANCH:-main}
      - ${DEV_BRANCH:-development}

env:
  DOCKER_REGISTRY: ${DOCKER_REGISTRY:-ghcr.io}
  DOCKER_USERNAME: ${{ github.repository_owner }}
  APP_NAME: ${APP_NAME:-pensum_run}
  IMAGE_NAME: ${{ github.repository_owner }}/${APP_NAME:-pensum_run}
  NODE_VERSION: ${NODE_VERSION:-22.14.0}

jobs:
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Load environment configuration
        run: |
          # Extract values from .env.config
          if [ -f .env.config ]; then
            export $(grep -v '^#' .env.config | xargs)
          fi
      
      - name: Set environment variables based on branch
        run: |
          if [[ $GITHUB_REF == refs/heads/${PROD_BRANCH:-main} ]]; then
            echo "APP_ENV=${PROD_ENV:-production}" >> $GITHUB_ENV
            echo "ENV_FILE=${PROD_ENV_FILE:-.env.prod}" >> $GITHUB_ENV
            echo "TAG=${PROD_ENV:-production}" >> $GITHUB_ENV
          else
            echo "APP_ENV=${DEV_ENV:-development}" >> $GITHUB_ENV
            echo "ENV_FILE=${DEV_ENV_FILE:-.env.dev}" >> $GITHUB_ENV
            echo "TAG=${DEV_ENV:-development}" >> $GITHUB_ENV
          fi
          
          echo "Using APP_ENV=${{ env.APP_ENV }}"
          echo "Using ENV_FILE=${{ env.ENV_FILE }}"
          echo "Using TAG=${{ env.TAG }}"
      
      # Set up Node.js for testing
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '${NODE_VERSION:-22.14.0}'
          cache: 'npm'
      
      # Install dependencies
      - name: Install dependencies
        run: npm ci
      
      # Run tests if you have them
      - name: Run tests
        run: npm test || echo "No tests specified"
      
      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Extract metadata
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=ref,event=branch
      
      # Build and push Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-${{ github.sha }}
          build-args: |
            NODE_VERSION=${NODE_VERSION:-22.14.0}
            NODE_VERSION_TAG=${NODE_VERSION_TAG:-slim}
            APP_ENV=${{ env.APP_ENV }}
            ENV_FILE=${{ env.ENV_FILE }}
  
  deploy:
    name: Deploy to Server
    needs: build
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    
    steps:
      - name: Load environment configuration
        run: |
          # Here we would load from .env.config, but in GitHub Actions
          # we need to check out the repo first, so we use default values
          echo "Using default config values"
      
      - name: Set environment variables based on branch
        run: |
          if [[ $GITHUB_REF == refs/heads/${PROD_BRANCH:-main} ]]; then
            echo "APP_ENV=${PROD_ENV:-production}" >> $GITHUB_ENV
            echo "ENV_FILE=${PROD_ENV_FILE:-.env.prod}" >> $GITHUB_ENV
            echo "TAG=${PROD_ENV:-production}" >> $GITHUB_ENV
            echo "CONTAINER_NAME=${PROD_CONTAINER_NAME:-pensum_run-prod}" >> $GITHUB_ENV
            echo "PORT=${PROD_PORT:-8080}" >> $GITHUB_ENV
          else
            echo "APP_ENV=${DEV_ENV:-development}" >> $GITHUB_ENV
            echo "ENV_FILE=${DEV_ENV_FILE:-.env.dev}" >> $GITHUB_ENV
            echo "TAG=${DEV_ENV:-development}" >> $GITHUB_ENV
            echo "CONTAINER_NAME=${DEV_CONTAINER_NAME:-pensum_run-dev}" >> $GITHUB_ENV
            echo "PORT=${DEV_PORT:-3000}" >> $GITHUB_ENV
          fi

      - name: Print env variables
        run: |
          echo "DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}"
          echo "IMAGE_NAME: ${{ env.IMAGE_NAME }}"
          echo "TAG: ${{ env.TAG }}"
          echo "APP_ENV: ${{ env.APP_ENV }}"
          echo "CONTAINER_NAME: ${{ env.CONTAINER_NAME }}"
          echo "SHA: ${{ github.sha }}"
          
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          envs: DOCKER_REGISTRY,IMAGE_NAME,GITHUB_SHA,GITHUB_RUN_NUMBER,APP_ENV,TAG,CONTAINER_NAME,PORT
          script: |
            # Debug - print variables
            echo "Using DOCKER_REGISTRY: $DOCKER_REGISTRY"
            echo "Using IMAGE_NAME: $IMAGE_NAME"
            echo "Using TAG: $TAG"
            echo "Using APP_ENV: $APP_ENV"
            echo "Using CONTAINER_NAME: $CONTAINER_NAME"
            echo "This is deployment #${GITHUB_RUN_NUMBER}"
            
            # Create deployment directory if it doesn't exist
            mkdir -p ~/app-deployment/$APP_ENV
            cd ~/app-deployment/$APP_ENV

            # Remove previous deployment counter files
            rm -f deployment_count_*.txt
            
            # Create deployment counter file
            echo "Deployment #${GITHUB_RUN_NUMBER} (SHA: ${GITHUB_SHA:0:7}) deployed at $(date)" > deployment_count_${GITHUB_RUN_NUMBER}.txt
            
            # Create release history
            echo "Deployment #${GITHUB_RUN_NUMBER} (ENV: $APP_ENV, SHA: ${GITHUB_SHA:0:7}) deployed at $(date)" >> deployment_history.log
            
            # Pull the latest image
            echo "Pulling image: $DOCKER_REGISTRY/$IMAGE_NAME:$TAG"
            docker pull $DOCKER_REGISTRY/$IMAGE_NAME:$TAG
            
            # Create or update docker-compose.yml with the EXACT image name that we pulled
            cat > docker-compose.yml << EOL
            services:
              app:
                image: $DOCKER_REGISTRY/$IMAGE_NAME:$TAG
                container_name: $CONTAINER_NAME
                restart: unless-stopped
                ports:
                  # Map the port based on the environment
                  - "${PORT:-3000}:${PORT:-3000}"
                environment:
                  - LOG_LEVEL=${PROD_LOG_LEVEL:-info}
                  - APP_ENV=$APP_ENV
                  - APP_DEPLOYMENT=${GITHUB_RUN_NUMBER}
                  # Make sure PORT is set explicitly to match the environment
                  - PORT=${PORT:-3000}
                labels:
                  - "deployment.number=${GITHUB_RUN_NUMBER}"
                  - "deployment.sha=${GITHUB_SHA:0:7}"
                  - "deployment.date=$(date)"
                  - "deployment.environment=$APP_ENV"
            EOL
            
            # Show the docker-compose file
            echo "Docker compose file:"
            cat docker-compose.yml
            
            # Deploy with docker-compose
            echo "Stopping previous container"
            docker-compose down || true
            
            echo "Starting new container"
            docker-compose up -d
            
            # Verify container is running
            echo "Running containers:"
            docker ps
            
            # Check logs
            sleep 2
            docker logs $CONTAINER_NAME || echo "No logs available yet"
            
            # List deployment files
            ls -la deployment_*.txt
